import{P as x,m as P,n as T,j as L,o as k,p as B,q as z,B as U,r as D,s as M,H as F,W as N,A as W,t as g,v as G,C as m,d as O,E,w as S,x as Z,y as Y,z as R,J as H,M as X,N as j}from"./Screen-okPZKpqq.js";const V=20000630;function q(e,l){if(e.getUint32(0,!0)!=V)throw new Error("Incorrect OpenEXR format");const s=e.getUint8(4),r=e.getUint8(5),n={singleTile:!!(r&2),longName:!!(r&4),deepFormat:!!(r&8),multiPart:!!(r&16)};l.value=8;const i={};let t=!0;for(;t;){const a=x(e.buffer,l);if(!a)t=!1;else{const c=x(e.buffer,l),o=P(e,l),u=T(e,l,c,o);u===void 0?L.Warn(`Unknown header attribute type ${c}'.`):i[a]=u}}if(r&-5)throw new Error("Unsupported file format");return{version:s,spec:n,...i}}function J(e){let l=e.byteLength;const s=[];let r=0;const n=new DataView(e);for(;l>0;){const i=n.getInt8(r++);if(i<0){const t=-i;l-=t+1;for(let a=0;a<t;a++)s.push(n.getUint8(r++))}else{const t=i;l-=2;const a=n.getUint8(r++);for(let c=0;c<t+1;c++)s.push(a)}}return s}function v(e){return new DataView(e.array.buffer,e.offset.value,e.size)}function $(e){const l=e.viewer.buffer.slice(e.offset.value,e.offset.value+e.size),s=new Uint8Array(J(l)),r=new Uint8Array(s.length);return k(s),B(s,r),new DataView(r.buffer)}function I(e){const l=e.array.slice(e.offset.value,e.offset.value+e.size),s=fflate.unzlibSync(l),r=new Uint8Array(s.length);return k(s),B(s,r),new DataView(r.buffer)}function K(e){const l=e.array.slice(e.offset.value,e.offset.value+e.size),s=fflate.unzlibSync(l),r=e.lines*e.channels*e.width,n=e.type==1?new Uint16Array(r):new Uint32Array(r);let i=0,t=0;const a=new Array(4);for(let c=0;c<e.lines;c++)for(let o=0;o<e.channels;o++){let u=0;switch(e.type){case 1:a[0]=i,a[1]=a[0]+e.width,i=a[1]+e.width;for(let h=0;h<e.width;++h){const w=s[a[0]++]<<8|s[a[1]++];u+=w,n[t]=u,t++}break;case 2:a[0]=i,a[1]=a[0]+e.width,a[2]=a[1]+e.width,i=a[2]+e.width;for(let h=0;h<e.width;++h){const w=s[a[0]++]<<24|s[a[1]++]<<16|s[a[2]++]<<8;u+=w,n[t]=u,t++}break}}return new DataView(n.buffer)}function Q(e){const l=e.viewer,s={value:e.offset.value},r=new Uint16Array(e.width*e.scanlineBlockSize*(e.channels*e.type)),n=new Uint8Array(U);let i=0;const t=new Array(e.channels);for(let f=0;f<e.channels;f++)t[f]={},t[f].start=i,t[f].end=t[f].start,t[f].nx=e.width,t[f].ny=e.lines,t[f].size=e.type,i+=t[f].nx*t[f].ny*t[f].size;const a=z(l,s),c=z(l,s);if(c>=U)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(a<=c)for(let f=0;f<c-a+1;f++)n[f+a]=D(l,s);const o=new Uint16Array(G),u=M(n,o),h=P(l,s);F(e.array,l,s,h,r,i);for(let f=0;f<e.channels;++f){const p=t[f];for(let y=0;y<t[f].size;++y)N(r,p.start+y,p.nx,p.size,p.ny,p.nx*p.size,u)}W(o,r,i);let w=0;const C=new Uint8Array(r.buffer.byteLength);for(let f=0;f<e.lines;f++)for(let p=0;p<e.channels;p++){const y=t[p],b=y.nx*y.size,A=new Uint8Array(r.buffer,y.end*g,b*g);C.set(A,w),w+=b*g,y.end+=b}return new DataView(C.buffer)}async function d(e,l,s,r){const n={size:0,viewer:l,array:new Uint8Array(l.buffer),offset:s,width:e.dataWindow.xMax-e.dataWindow.xMin+1,height:e.dataWindow.yMax-e.dataWindow.yMin+1,channels:e.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(e.compression){case m.NO_COMPRESSION:n.lines=1,n.uncompress=v;break;case m.RLE_COMPRESSION:n.lines=1,n.uncompress=$;break;case m.ZIPS_COMPRESSION:n.lines=1,n.uncompress=I,await O.LoadScriptAsync(E.FFLATEUrl);break;case m.ZIP_COMPRESSION:n.lines=16,n.uncompress=I,await O.LoadScriptAsync(E.FFLATEUrl);break;case m.PIZ_COMPRESSION:n.lines=32,n.uncompress=Q;break;case m.PXR24_COMPRESSION:n.lines=16,n.uncompress=K,await O.LoadScriptAsync(E.FFLATEUrl);break;default:throw new Error(m[e.compression]+" is unsupported")}n.scanlineBlockSize=n.lines;const i={};for(const o of e.channels)switch(o.name){case"R":case"G":case"B":case"A":i[o.name]=!0,n.type=o.pixelType;break;case"Y":i[o.name]=!0,n.type=o.pixelType;break}let t=!1;if(i.R&&i.G&&i.B&&i.A)n.outputChannels=4,n.decodeChannels={R:0,G:1,B:2,A:3};else if(i.R&&i.G&&i.B)t=!0,n.outputChannels=4,n.decodeChannels={R:0,G:1,B:2,A:3};else if(i.R&&i.G)n.outputChannels=2,n.decodeChannels={R:0,G:1};else if(i.R)n.outputChannels=1,n.decodeChannels={R:0};else if(i.Y)n.outputChannels=1,n.decodeChannels={Y:0};else throw new Error("EXRLoader.parse: file contains unsupported data channels.");if(n.type===1)switch(r){case S.Float:n.getter=Z,n.inputSize=g;break;case S.HalfFloat:n.getter=z,n.inputSize=g;break}else if(n.type===2)switch(r){case S.Float:n.getter=H,n.inputSize=R;break;case S.HalfFloat:n.getter=Y,n.inputSize=R}else throw new Error("Unsupported pixelType "+n.type+" for "+e.compression);n.blockCount=n.height/n.scanlineBlockSize;for(let o=0;o<n.blockCount;o++)X(l,s);const a=n.width*n.height*n.outputChannels;switch(r){case S.Float:n.byteArray=new Float32Array(a),n.textureType=1,t&&n.byteArray.fill(1,0,a);break;case S.HalfFloat:n.byteArray=new Uint16Array(a),n.textureType=2,t&&n.byteArray.fill(15360,0,a);break;default:throw new Error("Unsupported type: "+r)}let c=0;for(const o of e.channels)n.decodeChannels[o.name]!==void 0&&(n.channelLineOffsets[o.name]=c*n.width),c+=o.pixelType*2;return n.bytesPerLine=n.width*c,n.outLineWidth=n.width*n.outputChannels,e.lineOrder==="INCREASING_Y"?n.scanOrder=o=>o:n.scanOrder=o=>n.height-1-o,n.outputChannels==4?(n.format=5,n.linearSpace=!0):(n.format=6,n.linearSpace=!1),n}function ee(e,l,s,r){const n={value:0};for(let i=0;i<e.height/e.scanlineBlockSize;i++){const t=j(s,r)-l.dataWindow.yMin;e.size=P(s,r),e.lines=t+e.scanlineBlockSize>e.height?e.height-t:e.scanlineBlockSize;const c=e.size<e.lines*e.bytesPerLine&&e.uncompress?e.uncompress(e):v(e);r.value+=e.size;for(let o=0;o<e.scanlineBlockSize;o++){const u=i*e.scanlineBlockSize,h=o+e.scanOrder(u);if(h>=e.height)continue;const w=o*e.bytesPerLine,C=(e.height-1-h)*e.outLineWidth;for(let f=0;f<e.channels;f++){const p=l.channels[f].name,y=e.channelLineOffsets[p],b=e.decodeChannels[p];if(b!==void 0){n.value=w+y;for(let A=0;A<e.width;A++){const _=C+A*e.outputChannels+b;e.byteArray&&(e.byteArray[_]=e.getter(c,n))}}}}}}class ne{constructor(){this.supportCascades=!1}loadCubeData(l,s,r,n,i){throw".exr not supported in Cube."}loadData(l,s,r){const n=new DataView(l.buffer),i={value:0},t=q(n,i);d(t,n,i,E.DefaultOutputType).then(a=>{ee(a,t,n,i);const c=t.dataWindow.xMax-t.dataWindow.xMin+1,o=t.dataWindow.yMax-t.dataWindow.yMin+1;r(c,o,s.generateMipMaps,!1,()=>{const u=s.getEngine();s.format=t.format,s.type=a.textureType,s.invertY=!1,s._gammaSpace=!t.linearSpace,a.byteArray&&u._uploadDataToTextureDirectly(s,a.byteArray,0,0,void 0,!0)})}).catch(a=>{L.Error("Failed to load EXR texture: ",a)})}}const se=Object.freeze(Object.defineProperty({__proto__:null,_ExrTextureLoader:ne},Symbol.toStringTag,{value:"Module"}));export{d as C,J as D,q as G,ee as S,Q as U,ne as _,K as a,v as b,$ as c,I as d,se as e};
